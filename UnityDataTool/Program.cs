using System;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.IO;
using UnityDataTools.Analyzer;
using UnityDataTools.Analyzer.Processors;
using UnityDataTools.ReferenceFinder;
using UnityDataTools.TextDumper;
using UnityDataTools.FileSystem;

namespace UnityDataTools.UnityDataTool
{
    public static class Program
    {
        public static int Main(string[] args)
        {
            var rootCommand = new RootCommand();

            {
                var pathArg = new Argument<DirectoryInfo>("path", "The path to the directory containing the files to analyze").ExistingOnly();
                var oOpt = new Option<string>(aliases: new[] { "--output-file", "-o" }, description: "Filename of the output database", getDefaultValue: () => "database.db");
                var rOpt = new Option<bool>(aliases: new[] { "--extract-references", "-r" }, description: "Extract all object references and add them in the 'refs' table");
                var pOpt = new Option<string>(aliases: new[] { "--search-pattern", "-p" }, description: "File search pattern", getDefaultValue: () => "*");

                var analyzeCommand = new Command("analyze", "Analyze AssetBundles or SerializedFiles.")
                {
                    pathArg,
                    oOpt,
                    rOpt,
                    pOpt,
                };

                analyzeCommand.AddAlias("analyse");
                analyzeCommand.SetHandler(
                    (DirectoryInfo di, string o, bool r, string p) => HandleAnalyze(di, o, r, p),
                    pathArg, oOpt, rOpt, pOpt);

                rootCommand.AddCommand(analyzeCommand);
            }

            {
                var pathArg = new Argument<FileInfo>("databasePath", "The path to the database generated by the 'analyze' command using --extract-references").ExistingOnly();
                var oOpt = new Option<string>(aliases: new[] { "--output-file", "-o" }, description: "Output file", getDefaultValue: () => "references.txt");
                var aOpt = new Option<bool>(aliases: new[] { "--find-all", "-a" }, description: "Find all reference chains originating from the same asset (instead of only one), can be very slow");
                var nOpt = new Option<string>(aliases: new[] { "--object-name", "-n" }, description: "Object name");
                var tOpt = new Option<string>(aliases: new[] { "--object-type", "-t" }, description: "Optional object type when searching by name");
                var iOpt = new Option<long?>(aliases: new[] { "--object-id", "-i" }, description: "Object id");

                var findRefsCommand = new Command("find-refs", "Find reference chains to specified object(s).")
                {
                    pathArg,
                    oOpt,
                    aOpt,
                    nOpt,
                    tOpt,
                    iOpt,
                };

                findRefsCommand.SetHandler(
                    (FileInfo fi, string o, long? a, string n, string t, bool i) => HandleFindReferences(fi, o, a, n, t, i),
                    pathArg, oOpt, aOpt, nOpt, tOpt, iOpt);

                rootCommand.Add(findRefsCommand);
            }

            {
                var pathArg = new Argument<FileInfo>("filename", "The path of the file to dump").ExistingOnly();
                var fOpt = new Option<DumpFormat>(aliases: new[] { "--output-format", "-f" }, description: "Output format", getDefaultValue: () => DumpFormat.Text);
                var sOpt = new Option<bool>(aliases: new[] { "--skip-large-arrays", "-s" }, description: "Do not dump large arrays of basic data types");

                var dumpCommand = new Command("dump", "Dump the content of an AssetBundle or SerializedFile.")
                {
                    pathArg,
                    fOpt,
                    sOpt,
                };
                dumpCommand.SetHandler(
                    (FileInfo fi, DumpFormat f, bool s) => HandleDump(fi, f, s),
                    pathArg, fOpt, sOpt);

                rootCommand.AddCommand(dumpCommand);
            }

            {
                var pathArg = new Argument<FileInfo>("filename", "The path of the archive file").ExistingOnly();

                var extractArchiveCommand = new Command("extract", "Extract the archive.")
                {
                    pathArg,
                };

                extractArchiveCommand.SetHandler(
                    (FileInfo fi) => HandleExtractArchive(fi),
                    pathArg);

                var listArchiveCommand = new Command("list", "List the content of an archive.")
                {
                    pathArg,
                };

                listArchiveCommand.SetHandler(
                    (FileInfo fi) => HandleListArchive(fi),
                    pathArg);

                var archiveCommand = new Command("archive", "Unity Archive (AssetBundle) functions.")
                {
                    extractArchiveCommand,
                    listArchiveCommand,
                };

                rootCommand.AddCommand(archiveCommand);
            }

            return rootCommand.Invoke(args);
        }

        enum DumpFormat
        {
            Text,
        }

        static int HandleAnalyze(DirectoryInfo path, string outputFile, bool extractReferences, string searchPattern)
        {
            var analyzer = new AnalyzerTool();

            using var texture2DProcessor = new Texture2DProcessor();
            analyzer.AddProcessor("Texture2D", texture2DProcessor);

            using var meshProcessor = new MeshProcessor();
            analyzer.AddProcessor("Mesh", meshProcessor);

            using var shaderProcessor = new ShaderProcessor();
            analyzer.AddProcessor("Shader", shaderProcessor);

            using var audioProcessor = new AudioClipProcessor();
            analyzer.AddProcessor("AudioClip", audioProcessor);

            using var animationClipProcessor = new AnimationClipProcessor();
            analyzer.AddProcessor("AnimationClip", animationClipProcessor);

            using var assetBundleProcessor = new AssetBundleProcessor();
            analyzer.AddProcessor("AssetBundle", assetBundleProcessor);

            return analyzer.Analyze(path.FullName, outputFile, searchPattern, extractReferences);
        }

        static int HandleFindReferences(FileInfo databasePath, string outputFile, long? objectId, string objectName, string objectType, bool findAll)
        {
            var finder = new ReferenceFinderTool();

            if ((objectId != null && objectName != "") || (objectId == null && objectName == ""))
            {
                Console.Error.WriteLine("A value must be provided for either --object-id or --object-name.");
                return 1;
            }

            if (objectId != null)
            {
                return finder.FindReferences(objectId.Value, databasePath.FullName, outputFile, findAll);
            }
            else
            {
                return finder.FindReferences(objectName, objectType, databasePath.FullName, outputFile, findAll);
            }
        }

        static int HandleDump(FileInfo filename, DumpFormat format, bool skipLargeArrays)
        {
            switch (format)
            {
                case DumpFormat.Text:
                {
                    var textDumper = new TextDumperTool();
                    return textDumper.Dump(filename.FullName, Environment.CurrentDirectory, skipLargeArrays);
                }
            }

            return 1;
        }

        static int HandleExtractArchive(FileInfo filename)
        {
            try
            {
                using var archive = UnityFileSystem.MountArchive(filename.FullName, "/");
                foreach (var node in archive.Nodes)
                {
                    Console.WriteLine($"Extracting {node.Path}...");
                    CopyFile("/" + node.Path, Path.GetFileName(node.Path));
                }
            }
            catch (NotSupportedException)
            {
                Console.Error.WriteLine("Error opening archive!");
                return 1;
            }

            return 0;
        }

        static int HandleListArchive(FileInfo filename)
        {
            try
            {
                using var archive = UnityFileSystem.MountArchive(filename.FullName, "/");
                foreach (var node in archive.Nodes)
                {
                    Console.WriteLine($"{node.Path}");
                    Console.WriteLine($"  Size: {node.Size}");
                    Console.WriteLine($"  Flags: {node.Flags}");
                    Console.WriteLine();
                }
            }
            catch (NotSupportedException)
            {
                Console.Error.WriteLine("Error opening archive!");
                return 1;
            }

            return 0;
        }

        static void CopyFile(string source, string dest)
        {
            using var sourceFile = UnityFileSystem.OpenFile(source);
            using var destFile = new FileStream(dest, FileMode.Create);

            const int blockSize = 256 * 1024;
            var buffer = new byte[blockSize];
            long actualSize;

            do
            {
                actualSize = sourceFile.Read(blockSize, buffer);
                destFile.Write(buffer, 0, (int)actualSize);
            }
            while (actualSize == blockSize);
        }
    }
}
