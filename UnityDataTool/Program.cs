using System;
using System.CommandLine;
using System.CommandLine.Invocation;
using System.IO;
using UnityDataTools.Analyzer;
using UnityDataTools.Analyzer.Processors;
using UnityDataTools.ReferenceFinder;
using UnityDataTools.TextDumper;
using UnityDataTools.FileSystem;

namespace UnityDataTools.UnityDataTool
{
    public static class Program
    {
        public static int Main(string[] args)
        {
            var analyzeCommand = new Command("analyze", "Analyze AssetBundles or SerializedFiles.")
            {
                new Argument<DirectoryInfo>("path", "The path to the directory containing the files to analyze").ExistingOnly(),
                new Option<string>(aliases: new[] { "--output-file", "-o" }, description: "Filename of the output database", getDefaultValue: () => "database.db"),
                new Option<bool>(aliases: new[] { "--extract-references", "-r" }, description: "Extract all object references and add them in the 'refs' table"),
                new Option<string>(aliases: new[] { "--search-pattern", "-p" }, description: "File search pattern", getDefaultValue: () => "*"),
            };
            analyzeCommand.AddAlias("analyse");
            analyzeCommand.Handler = CommandHandler.Create<DirectoryInfo, string, bool, string>(HandleAnalyze);

            var findRefsCommand = new Command("find-refs", "Find reference chains to specified object(s).")
            {
                new Argument<FileInfo>("databasePath", "The path to the database generated by the 'analyze' command using --extract-references").ExistingOnly(),
                new Option<string>(aliases: new[] { "--output-file", "-o" }, description: "Output file", getDefaultValue: () => "references.txt"),
                new Option<bool>(aliases: new[] { "--find-all", "-a" }, description: "Find all reference chains originating from the same asset (instead of only one), can be very slow"),
                new Option<string>(aliases: new[] { "--object-name", "-n" }, description: "Object name"),
                new Option<string>(aliases: new[] { "--object-type", "-t" }, description: "Optional object type when searching by name"),
                new Option<long?>(aliases: new[] { "--object-id", "-i" }, description: "Object id"),
            };
            findRefsCommand.Handler = CommandHandler.Create<FileInfo, string, long?, string, string, bool>(HandleFindReferences);

            var dumpCommand = new Command("dump", "Dump the content of an AssetBundle or SerializedFile.")
            {
                new Argument<FileInfo>("filename", "The path of the file to dump").ExistingOnly(),
                new Option<DumpFormat>(aliases: new[] { "--output-format", "-f" }, description: "Output format", getDefaultValue: () => DumpFormat.Text),
                new Option<bool>(aliases: new[] { "--skip-large-arrays", "-s" }, description: "Do not dump large arrays of basic data types"),
            };
            dumpCommand.Handler = CommandHandler.Create<FileInfo, DumpFormat, bool>(HandleDump);

            var extractArchiveCommand = new Command("extract", "Extract the archive.")
            {
                new Argument<FileInfo>("filename", "The path of the archive file").ExistingOnly(),
            };
            var listArchiveCommand = new Command("list", "List the content of an archive.")
            {
                new Argument<FileInfo>("filename", "The path of the archive file").ExistingOnly(),
            };
            var archiveCommand = new Command("archive", "Unity Archive (AssetBundle) functions.")
            {
                extractArchiveCommand,
                listArchiveCommand,
            };
            extractArchiveCommand.Handler = CommandHandler.Create<FileInfo>(HandleExtractArchive);
            listArchiveCommand.Handler = CommandHandler.Create<FileInfo>(HandleListArchive);

            var cmd = new RootCommand()
            {
                analyzeCommand,
                findRefsCommand,
                dumpCommand,
                archiveCommand,
            };

            return cmd.Invoke(args);
        }

        enum DumpFormat
        {
            Text,
        }

        static int HandleAnalyze(DirectoryInfo path, string outputFile, bool extractReferences, string searchPattern)
        {
            var analyzer = new AnalyzerTool();

            using var texture2DProcessor = new Texture2DProcessor();
            analyzer.AddProcessor("Texture2D", texture2DProcessor);

            using var meshProcessor = new MeshProcessor();
            analyzer.AddProcessor("Mesh", meshProcessor);

            using var shaderProcessor = new ShaderProcessor();
            analyzer.AddProcessor("Shader", shaderProcessor);

            using var audioProcessor = new AudioClipProcessor();
            analyzer.AddProcessor("AudioClip", audioProcessor);

            using var animationClipProcessor = new AnimationClipProcessor();
            analyzer.AddProcessor("AnimationClip", animationClipProcessor);

            using var assetBundleProcessor = new AssetBundleProcessor();
            analyzer.AddProcessor("AssetBundle", assetBundleProcessor);

            return analyzer.Analyze(path.FullName, outputFile, searchPattern, extractReferences);
        }

        static int HandleFindReferences(FileInfo databasePath, string outputFile, long? objectId, string objectName, string objectType, bool findAll)
        {
            var finder = new ReferenceFinderTool();

            if ((objectId != null && objectName != "") || (objectId == null && objectName == ""))
            {
                Console.Error.WriteLine("A value must be provided for either --object-id or --object-name.");
                return 1;
            }

            if (objectId != null)
            {
                return finder.FindReferences(objectId.Value, databasePath.FullName, outputFile, findAll);
            }
            else
            {
                return finder.FindReferences(objectName, objectType, databasePath.FullName, outputFile, findAll);
            }
        }

        static int HandleDump(FileInfo filename, DumpFormat format, bool skipLargeArrays)
        {
            switch (format)
            {
                case DumpFormat.Text:
                {
                    var textDumper = new TextDumperTool();
                    return textDumper.Dump(filename.FullName, Environment.CurrentDirectory, skipLargeArrays);
                }
            }

            return 1;
        }

        static int HandleExtractArchive(FileInfo filename)
        {
            try
            {
                using var archive = UnityFileSystem.MountArchive(filename.FullName, "/");
                foreach (var node in archive.Nodes)
                {
                    Console.WriteLine($"Extracting {node.Path}...");
                    CopyFile("/" + node.Path, Path.GetFileName(node.Path));
                }
            }
            catch (NotSupportedException)
            {
                Console.Error.WriteLine("Error opening archive!");
                return 1;
            }

            return 0;
        }

        static int HandleListArchive(FileInfo filename)
        {
            try
            {
                using var archive = UnityFileSystem.MountArchive(filename.FullName, "/");
                foreach (var node in archive.Nodes)
                {
                    Console.WriteLine($"{node.Path}");
                    Console.WriteLine($"  Size: {node.Size}");
                    Console.WriteLine($"  Flags: {node.Flags}");
                    Console.WriteLine();
                }
            }
            catch (NotSupportedException)
            {
                Console.Error.WriteLine("Error opening archive!");
                return 1;
            }

            return 0;
        }

        static void CopyFile(string source, string dest)
        {
            using var sourceFile = UnityFileSystem.OpenFile(source);
            using var destFile = new FileStream(dest, FileMode.Create);

            const int blockSize = 256 * 1024;
            var buffer = new byte[blockSize];
            long actualSize;

            do
            {
                actualSize = sourceFile.Read(blockSize, buffer);
                destFile.Write(buffer, 0, (int)actualSize);
            }
            while (actualSize == blockSize);
        }
    }
}
